const CACHE_NAMES = {
    STATIC: "static-cache-v1",
    FONTS: "fonts-cache-v1",
    PAGES: "pages-cache-v1",
    OFFLINE: "offline-cache-v1",
    CRITICAL: "critical-cache-v1",
  },
  SW_VERSION = "1.0.7",
  OFFLINE_PAGE = "/fallback/offline.html",
  CRITICAL_RESOURCES = ["/manifest.webmanifest", "/favicon.ico", "/robots.txt"],
  CACHE_DURATION = 31536e6,
  CHECK_INTERVAL = 3e5,
  INSTALL_SESSION_KEY = "install-session",
  INSTALL_PROMPT_DELAY = 8e3,
  SESSION_DURATION = 864e5,
  SESSION_UPDATE_INTERVAL = 1e3,
  NOTIFICATION_STATE_KEY = "notification-state",
  INSTALL_NOTIFICATION_PENDING_KEY = "install-notification-pending";
importScripts("https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"),
  importScripts("https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js");
const firebase = self.firebase,
  firebaseConfig = {
    apiKey: "AIzaSyAQP_VjdlDv915rj1_eqlq0BnJGCB1lJYw",
    authDomain: "zendo-aarush.firebaseapp.com",
    projectId: "zendo-aarush",
    storageBucket: "zendo-aarush.firebasestorage.app",
    messagingSenderId: "756455688246",
    appId: "1:756455688246:web:d72db4298952b3e702b097",
    measurementId: "G-RNN756TW7T",
  };
firebase.initializeApp(firebaseConfig);
const messaging = firebase.messaging();
messaging.onBackgroundMessage((e) => {
  console.log("Received background message:", e);
  let n = [];
  try {
    e.data?.actions && (n = JSON.parse(e.data.actions));
  } catch (e) {
    console.error("Error parsing notification actions:", e);
  }
  const t = e.notification?.title || "Zendo",
    s = {
      body: e.notification?.body || "You have a new message",
      icon: "/assets/icons/maskable-icon.png",
      badge: "/assets/icons/maskable-icon.png",
      tag: e.data?.tag || "default",
      data: { ...e.data, url: e.data?.url || "/", timestamp: e.data?.timestamp || Date.now() },
      actions: n,
      requireInteraction: !0,
      silent: !1,
      vibrate: [200, 100, 200],
      renotify: !0,
    };
  return self.registration.showNotification(t, s);
}),
  self.addEventListener("install", (e) => {
    e.waitUntil(
      Promise.all([
        caches.open(CACHE_NAMES.OFFLINE).then((e) =>
          e.add(OFFLINE_PAGE).catch((e) => {
            console.warn("[Service Worker] Could not cache offline page:", e);
          })
        ),
        caches.open(CACHE_NAMES.CRITICAL).then((e) =>
          Promise.allSettled(
            CRITICAL_RESOURCES.map((n) =>
              e.add(n).catch((e) => {
                console.warn(`[Service Worker] Could not cache ${n}:`, e);
              })
            )
          )
        ),
      ])
        .then(() => self.skipWaiting())
        .catch((e) => {
          console.error("[Service Worker] Installation failed:", e);
        })
    );
  }),
  self.addEventListener("activate", (e) => {
    e.waitUntil(
      caches
        .keys()
        .then((e) =>
          Promise.all(
            e.map((e) =>
              Object.values(CACHE_NAMES).includes(e) ? Promise.resolve() : caches.delete(e)
            )
          )
        )
        .then(() => self.clients.claim())
        .then(() => {
          checkPendingInstallNotification();
        })
        .catch((e) => {
          console.error("[Service Worker] Activation failed:", e);
        })
    );
  });
let cacheCheckInterval,
  sessionTracker = null,
  sessionInterval = null,
  isSessionInitialized = !1,
  toastState = null;
async function getInstallSession() {
  try {
    const e = await caches.open(CACHE_NAMES.STATIC),
      n = await e.match("install-session");
    if (n) {
      return await n.json();
    }
  } catch (e) {
    console.warn("[Service Worker] Could not retrieve install session:", e);
  }
  return null;
}
async function setInstallSession(e) {
  try {
    const n = await caches.open(CACHE_NAMES.STATIC),
      t = new Response(JSON.stringify(e), { headers: { "Content-Type": "application/json" } });
    await n.put("install-session", t);
  } catch (e) {
    console.warn("[Service Worker] Could not save install session:", e);
  }
}
async function clearInstallSession() {
  try {
    const e = await caches.open(CACHE_NAMES.STATIC);
    await e.delete("install-session"),
      (isSessionInitialized = !1),
      (sessionTracker = null),
      sessionInterval && (clearInterval(sessionInterval), (sessionInterval = null));
  } catch (e) {
    console.warn("[Service Worker] Could not clear install session:", e);
  }
}
function isSafariApple(e) {
  const n = /^((?!chrome|android).)*safari/i.test(e),
    t = /iPad|iPhone|iPod|Macintosh|MacIntel|MacPPC|Mac68K/.test(e);
  return n && t;
}
async function initializeSessionTracking(e) {
  if (isSessionInitialized)
    return void console.log("[Service Worker] Session already initialized, skipping");
  if (e.isInstalled)
    return void console.log("[Service Worker] User already installed - skipping session tracking");
  const n = await getInstallSession(),
    t = Date.now();
  n
    ? t - n.startTime > 864e5
      ? (await createNewSession(e, t),
        console.log("[Service Worker] Started new install session (expired)"))
      : ((sessionTracker = { ...n, lastUpdate: t, isActive: !0, isSafari: e.isSafari }),
        n.totalTime >= 8e3 && !n.hasShownPrompt
          ? await triggerInstallPrompt(n.isSafari)
          : (console.log(`[Service Worker] Resumed session - ${n.totalTime}ms / 8000ms`),
            startSessionTimer()))
    : (await createNewSession(e, t), console.log("[Service Worker] Started new install session")),
    (isSessionInitialized = !0);
}
async function createNewSession(e, n) {
  sessionInterval && (clearInterval(sessionInterval), (sessionInterval = null)),
    (sessionTracker = {
      startTime: n,
      totalTime: 0,
      hasShownPrompt: !1,
      userAgent: e.userAgent,
      isSafari: e.isSafari,
      lastUpdate: n,
      isActive: !0,
    }),
    await setInstallSession(sessionTracker),
    startSessionTimer();
}
function startSessionTimer() {
  sessionInterval && (clearInterval(sessionInterval), (sessionInterval = null)),
    console.log("[Service Worker] Starting session timer"),
    (sessionInterval = setInterval(async () => {
      if (!sessionTracker || !sessionTracker.isActive || sessionTracker.hasShownPrompt)
        return (
          console.log("[Service Worker] Stopping session timer - inactive or prompt shown"),
          clearInterval(sessionInterval),
          void (sessionInterval = null)
        );
      const e = Date.now(),
        n = e - sessionTracker.lastUpdate;
      (sessionTracker.totalTime += n),
        (sessionTracker.lastUpdate = e),
        await setInstallSession(sessionTracker),
        console.log(`[Service Worker] Session time: ${sessionTracker.totalTime}ms / 8000ms`),
        sessionTracker.totalTime >= 8e3 &&
          ((sessionTracker.hasShownPrompt = !0),
          await setInstallSession(sessionTracker),
          await triggerInstallPrompt(sessionTracker.isSafari),
          clearInterval(sessionInterval),
          (sessionInterval = null));
    }, 1e3));
}
function pauseSessionTracking() {
  sessionTracker &&
    sessionTracker.isActive &&
    ((sessionTracker.isActive = !1), console.log("[Service Worker] Session tracking paused"));
}
function resumeSessionTracking() {
  !sessionTracker ||
    sessionTracker.hasShownPrompt ||
    sessionTracker.isActive ||
    ((sessionTracker.isActive = !0),
    (sessionTracker.lastUpdate = Date.now()),
    console.log("[Service Worker] Session tracking resumed"),
    sessionInterval || startSessionTimer());
}
async function handleInstallSession(e) {
  e.isInstalled || e.cookieConsentVisible
    ? console.log(
        "[Service Worker] Skipping session tracking - installed or cookie consent visible"
      )
    : (isSessionInitialized || (await initializeSessionTracking(e)),
      e.hasOpenDialogs ? pauseSessionTracking() : resumeSessionTracking());
}
async function updateInstallSessionTiming(e) {
  sessionTracker &&
    isSessionInitialized &&
    (e.hasOpenDialogs ? pauseSessionTracking() : resumeSessionTracking());
}
async function handlePageVisibilityChange(e) {
  sessionTracker &&
    !sessionTracker.hasShownPrompt &&
    (e
      ? ((sessionTracker.isActive = !0),
        (sessionTracker.lastUpdate = Date.now()),
        sessionTracker.totalTime >= 8e3
          ? await triggerInstallPrompt(sessionTracker.isSafari)
          : startSessionTimer())
      : ((sessionTracker.isActive = !1),
        sessionInterval && (clearInterval(sessionInterval), (sessionInterval = null))));
}
function isCriticalResource(e) {
  return CRITICAL_RESOURCES.some((n) => e === n || e.endsWith(n));
}
async function handleCriticalResource(e) {
  try {
    const n = await caches.match(e);
    if (n) return n;
    const t = await fetch(e);
    if (t.ok)
      try {
        const n = await caches.open(CACHE_NAMES.CRITICAL),
          s = t.clone();
        await n.put(e, s);
      } catch (e) {}
    return t;
  } catch (n) {
    const t = await caches.match(e);
    if (t) return t;
    if (e.url.includes("manifest.webmanifest"))
      return new Response(
        JSON.stringify({
          name: "Zendo",
          short_name: "Zendo",
          start_url: "/",
          display: "standalone",
          background_color: "#000000",
          theme_color: "#000000",
          icons: [
            {
              src: "/assets/icons/maskable-icon.png",
              sizes: "512x512",
              type: "image/png",
              purpose: "maskable",
            },
          ],
        }),
        { headers: { "Content-Type": "application/manifest+json" }, status: 200 }
      );
    if (e.url.includes("favicon.ico")) {
      const e = atob(
          "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=="
        ),
        n = new Uint8Array(e.length);
      for (let t = 0; t < e.length; t++) n[t] = e.charCodeAt(t);
      return new Response(n, { headers: { "Content-Type": "image/png" }, status: 200 });
    }
    return new Response("Not Found", { status: 404 });
  }
}
async function handleNavigationRequest(e) {
  try {
    return await fetch(e);
  } catch (e) {
    try {
      const e = await caches.match(OFFLINE_PAGE);
      if (e) return processOfflinePage(e);
    } catch (e) {}
    return new Response(
      '<!DOCTYPE html>\n      <html>\n        <head>\n          <title>Offline</title>\n          <meta charset="utf-8">\n          <meta name="viewport" content="width=device-width, initial-scale=1">\n          <style>\n            body { \n              font-family: system-ui, sans-serif; \n              text-align: center; \n              padding: 2rem; \n              background: #f9fafb; \n            }\n            h1 { color: #111827; }\n          </style>\n        </head>\n        <body>\n          <h1>You\'re Offline</h1>\n          <p>Please check your internet connection and try again.</p>\n          <button onclick="window.location.reload()">Retry</button>\n        </body>\n      </html>',
      { headers: { "Content-Type": "text/html" }, status: 200 }
    );
  }
}
async function handleFontRequest(e) {
  try {
    const n = await caches.match(e);
    if (n) return n;
    const t = new Request(e.url, {
        method: "GET",
        mode: "no-cors",
        credentials: "omit",
        cache: "default",
      }),
      s = await fetch(t);
    if (0 === s.status || s.ok)
      try {
        const n = await caches.open(CACHE_NAMES.FONTS),
          t = s.clone();
        await n.put(e, t);
      } catch (e) {}
    return s;
  } catch (n) {
    const t = await caches.match(e);
    return (
      t ||
      (e.url.includes("googleapis.com") && e.url.includes("css")
        ? new Response(
            "/* Fallback font CSS */\n        @font-face {\n          font-family: 'Geist Sans';\n          font-style: normal;\n          font-weight: 400;\n          font-display: swap;\n          src: local('system-ui'), local('sans-serif');\n        }\n        @font-face {\n          font-family: 'Space Grotesk';\n          font-style: normal;\n          font-weight: 400;\n          font-display: swap;\n          src: local('system-ui'), local('sans-serif');\n        }",
            { headers: { "Content-Type": "text/css" }, status: 200 }
          )
        : new Response("Font not available offline", { status: 404 }))
    );
  }
}
async function handleStaticAssetRequest(e) {
  try {
    const n = await fetch(e);
    if (n.ok && shouldCacheAsset(e.url))
      try {
        const t = await caches.open(CACHE_NAMES.STATIC),
          s = n.clone();
        await t.put(e, s);
      } catch (e) {}
    return n;
  } catch (n) {
    const t = await caches.match(e);
    return (
      t ||
      new Response("Resource not available offline", {
        status: 404,
        headers: { "Content-Type": "text/plain" },
      })
    );
  }
}
function shouldCacheAsset(e) {
  return [".js", ".css", ".png", ".jpg", ".jpeg", ".svg", ".ico", ".woff", ".woff2", ".ttf"].some(
    (n) => e.includes(n)
  );
}
async function processOfflinePage(e) {
  try {
    const n = (await e.text()).replace(
      "</head>",
      "\n      <style>\n        body {\n          font-family: 'Geist Sans', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;\n        }\n        \n        h1, h2, h3, h4, h5, h6 {\n          font-family: 'Space Grotesk', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;\n        }\n        \n        * {\n          font-display: swap;\n        }\n      </style>\n    </head>"
    );
    return new Response(n, {
      headers: { "Content-Type": "text/html", "Cache-Control": "no-cache" },
      status: 200,
    });
  } catch (n) {
    return e;
  }
}
async function checkAndRefreshCache() {
  try {
    const e = await caches.open(CACHE_NAMES.OFFLINE);
    if (!(await e.match(OFFLINE_PAGE)))
      try {
        await e.add(OFFLINE_PAGE);
      } catch (e) {}
    await cleanupExpiredCaches();
  } catch (e) {}
}
async function cleanupExpiredCaches() {
  try {
    const e = Date.now(),
      n = await caches.keys();
    for (const t of n) {
      if (!Object.values(CACHE_NAMES).includes(t)) continue;
      const n = await caches.open(t),
        s = await n.keys();
      for (const t of s)
        try {
          const s = await n.match(t);
          if (s) {
            const a = s.headers.get("date");
            if (a) {
              e - new Date(a).getTime() > 31536e6 && (await n.delete(t));
            }
          }
        } catch (e) {
          continue;
        }
    }
  } catch (e) {}
}
function startCacheCheckInterval() {
  cacheCheckInterval && clearInterval(cacheCheckInterval),
    (cacheCheckInterval = setInterval(checkAndRefreshCache, 3e5));
}
async function checkPendingInstallNotification() {
  const e = await getPendingInstallNotification();
  e &&
    (console.log("[Service Worker] Found pending install notification, sending now..."),
    await sendInstallThankYouNotification(e),
    await clearPendingInstallNotification());
}
async function triggerInstallPrompt(e) {
  console.log("Triggering install prompt for Safari:", e);
}
async function setPendingInstallNotification(e) {
  console.log("Setting pending install notification:", e);
}
async function getPendingInstallNotification() {
  return console.log("Getting pending install notification"), null;
}
async function sendInstallThankYouNotification(e) {
  console.log("Sending install thank you notification:", e);
}
async function clearPendingInstallNotification() {
  console.log("Clearing pending install notification");
}
async function getNotificationState() {
  return console.log("Getting notification state"), { isShowing: !1, lastShown: 0, showCount: 0 };
}
async function setNotificationState(e) {
  console.log("Setting notification state:", e);
}
self.addEventListener("fetch", (e) => {
  const n = e.request,
    t = new URL(n.url);
  "GET" === n.method &&
    "chrome-extension:" !== t.protocol &&
    "moz-extension:" !== t.protocol &&
    (isCriticalResource(t.pathname)
      ? e.respondWith(handleCriticalResource(n))
      : t.hostname.includes("googleapis.com") || t.hostname.includes("gstatic.com")
        ? e.respondWith(handleFontRequest(n))
        : "navigate" !== n.mode
          ? t.origin !== self.location.origin || e.respondWith(handleStaticAssetRequest(n))
          : e.respondWith(handleNavigationRequest(n)));
}),
  self.addEventListener("message", (e) => {
    const { data: n, ports: t } = e;
    if (n && "GET_VERSION" === n.type) {
      const e = t[0];
      e &&
        e.postMessage({
          type: "VERSION",
          version: "1.0.7",
          cacheNames: CACHE_NAMES,
          timestamp: Date.now(),
        });
    } else if (n && "INIT_INSTALL_SESSION" === n.type) handleInstallSession(n.data);
    else if (n && "APP_INSTALLED" === n.type)
      clearInstallSession(),
        setPendingInstallNotification({ timestamp: Date.now(), type: "install-thank-you" }),
        console.log("[Service Worker] App installed - saved pending notification"),
        setTimeout(() => {
          checkPendingInstallNotification();
        }, 1e3);
    else if ("CHECK_CACHE" === n) checkAndRefreshCache();
    else if ("START_CACHE_CHECK" === n) startCacheCheckInterval();
    else if (n && "UPDATE_INSTALL_SESSION" === n.type) updateInstallSessionTiming(n.data);
    else if (n && "PAGE_VISIBILITY_CHANGE" === n.type) handlePageVisibilityChange(n.isVisible);
    else if (n && "GET_FCM_TOKEN" === n.type) {
      const e = t[0];
      e && e.postMessage({ token: null });
    } else
      n &&
        "TOAST_DISMISSED" === n.type &&
        setNotificationState({
          isShowing: !1,
          lastShown: Date.now(),
          showCount: toastState.showCount,
        });
  }),
  self.addEventListener("notificationclick", (e) => {
    e.notification.close();
    const n = e.action,
      t = e.notification.data || {};
    console.log("Notification clicked with action:", n, "and data:", t);
    let s = "/";
    "support" === n
      ? (s = "/kofi")
      : "explore" === n
        ? (s = "/")
        : "install-thank-you" !== e.notification.tag || n
          ? t.url && (s = t.url)
          : (s = "/kofi"),
      e.waitUntil(
        clients.matchAll({ type: "window", includeUncontrolled: !0 }).then((e) => {
          for (const n of e)
            if (n.url.includes(self.location.origin) && "focus" in n)
              return void n.focus().then(() => {
                if ("navigate" in n) return n.navigate(s);
              });
          if (clients.openWindow) return clients.openWindow(s);
        })
      );
  }),
  self.addEventListener("activate", () => {
    startCacheCheckInterval();
  }),
  checkAndRefreshCache(),
  getNotificationState().then((e) => {
    toastState = e;
  });
